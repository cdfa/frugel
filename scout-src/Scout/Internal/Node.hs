{-# LANGUAGE DataKinds #-}
{-# LANGUAGE DeriveAnyClass #-}
{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DerivingVia #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE UndecidableInstances #-}

module Scout.Internal.Node where

import Control.Limited
import Control.Sized
import Control.ValidEnumerable

import Data.Alphanumeric
import Data.Composition
import Data.Data                 ( Data )
import Data.GenValidity
import Data.GenValidity.Sequence ()
import Data.GenValidity.Text     ()
import Data.Has
import Data.Hidden
import Data.MultiSet             ( MultiSet )
import qualified Data.Text       as Text
import Data.Text.Optics
import Data.Validity.Extra
import Data.Validity.Sequence    ()
import Data.Whitespace

import Frugel
import Frugel.CstrSite.ValidEnumerable ()

import GHC.Generics              ( Associativity(..) )

import Generic.Data

import Numeric.Optics

import Optics.Extra.Scout

import PrettyPrinting.Expr

import qualified Relude.Unsafe   as Unsafe

import Scout.Orphans.Stream      ()

import Test.QuickCheck.Gen       as QuickCheck hiding ( vectorOf )

type CstrSite = ACstrSite Node

data Node = ExprNode Expr | DeclNode Decl | WhereNode WhereClause
    deriving ( Eq, Ord, Show, Generic, Data )

newtype Identifier = Identifier (NonEmpty Alphanumeric)
    deriving ( Eq, Ord, Show, Generic, Data )
    deriving newtype ( Semigroup )

data Expr
    = Variable ExprMeta Identifier
    | Abstraction AbstractionMeta Identifier Expr
    | Application ExprMeta Expr Expr
    | Sum ExprMeta Expr Expr
    | ExprCstrSite ExprMeta CstrSite
    deriving ( Eq, Ord, Show, Generic, Data )

data Decl
    = Decl { meta :: Meta, name :: Identifier, value :: Expr }
      -- , whereClause :: WhereClause
    | DeclCstrSite Meta CstrSite
    deriving ( Eq, Ord, Show, Generic, Data, Has Meta )

data WhereClause
    = WhereClause Meta (NonEmpty Decl) | WhereCstrSite Meta CstrSite
    deriving ( Eq, Ord, Show, Generic, Data, Has Meta )

type instance NodeOf Node = Node

type instance NodeOf Identifier = Node

type instance NodeOf Expr = Node

type instance NodeOf Decl = Node

type instance NodeOf WhereClause = Node

-- This has to live her instead of in Meta because ReifiedFunction depends on Expr
-- Could be removed by using data-diverse for Meta
data AbstractionMeta
    = AbstractionMeta { standardExprMeta :: ExprMeta
                      , reified :: Maybe (Hidden ReifiedFunction)
                      }
    deriving ( Eq, Ord, Show, Generic, Data, Has ExprMeta )

data ExprMeta = ExprMeta { standardMeta :: Meta, parenthesisLevels :: Int }
    deriving ( Eq, Ord, Show, Generic, Data, Has Meta )

-- It would be nicer if a heterogeneous type list wou ld be used instead, especially since elided and focused are not used by core Frugel
-- Meta had it's own modules someday, but the introduction of focusedNodeValues requires it's in here. Until there is time to pull in data-diverse
data Meta
    = Meta { interstitialWhitespace :: [Text] -- Invariant: the number of whitespace fragments should be equal to the number of places in a node where whitespace can exist
             -- If elided == True, the node with this metadata may not have been processed by a previous operation and a dummy result should be used
             -- The various node type should really be made parametric using hypertypes (https://github.com/lamdu/hypertypes), but there are higher priority tasks atm.
             -- ATM this is only set to true by evaluation and obeyed by pretty printing (not standard rendering)
           , elided :: Bool
             -- This is not the source of truth for the cursor location (that's in Model). This is used in evaluation to check if the node is focused
           , focused :: Bool
             -- Used to keep track of the values of all evaluation output resulting from evaluating this expression to weak-head normal form
           , evaluationOutput :: EvaluationOutput
           }
    deriving ( Eq, Ord, Show, Generic, Data )

type ReifiedFunction = Expr -> Limiter Expr

-- This lives here because of EvaluationError
-- Note that the output generated by evaluation of an expression to a function value is discarded when that function is applied to an argument
data EvaluationOutput
    = EvaluationOutput { errors :: MultiSet EvaluationError
                         -- Hidden because we typically do not want to consider these nodes when using template/uniplate
                         -- Be careful with evaluating the Nodes completely because they may be infinitely large. Use capTree to cap them to a certain depth
                       , focusedNodeValues :: Seq (Hidden Node)
                       }
    deriving ( Eq, Ord, Show, Generic, Data )
    deriving ( Semigroup, Monoid ) via (Generically EvaluationOutput)

-- This lives here because of dependency on Expr
data EvaluationError
    = TypeError TypeError
    | UnboundVariableError Identifier
    | ConflictingDefinitionsError Identifier
    | OutOfFuelError Expr
    deriving ( Eq, Show, Ord, Data )

data TypeError = TypeMismatchError ExpectedType Expr
    deriving ( Eq, Show, Ord, Data )

data ExpectedType = Function | Integer
    deriving ( Eq, Show, Ord, Data )

makeFieldLabelsNoPrefix ''Decl

makeFieldLabelsNoPrefix ''AbstractionMeta

makePrisms ''Node

makePrisms ''Identifier

makePrisms ''Expr

makePrisms ''Decl

makePrisms ''WhereClause

makeFieldLabelsNoPrefix ''ExprMeta

makeFieldLabelsNoPrefix ''Meta

makeFieldLabelsNoPrefix ''EvaluationOutput

instance Has Meta Node where
    getter (ExprNode n) = getter n
    getter (DeclNode n) = getter n
    getter (WhereNode n) = getter n
    modifier f n@(ExprNode _) = n & _ExprNode %~ modifier f
    modifier f n@(DeclNode _) = n & _DeclNode %~ modifier f
    modifier f n@(WhereNode _) = n & _WhereNode %~ modifier f

instance Has ExprMeta Expr where
    getter (Abstraction AbstractionMeta{..} _ _) = standardExprMeta
    getter (Variable meta _) = meta
    getter (Application meta _ _) = meta
    getter (Sum meta _ _) = meta
    getter (ExprCstrSite meta _) = meta
    modifier
        = over ((_Abstraction % _1 % #standardExprMeta)
                `adjoin` (_Variable % _1)
                `adjoin` (_Application % _1)
                `adjoin` (_Sum % _1)
                `adjoin` (_ExprCstrSite % _1))

instance Has Meta Expr where
    getter e = (standardMeta :: ExprMeta -> Meta) $ getter e
    modifier = over (exprMeta % #standardMeta)

exprMeta :: Lens' Expr ExprMeta
exprMeta = hasLens

declMeta :: Lens' Decl Meta
declMeta = hasLens

whereClauseMeta :: Lens' WhereClause Meta
whereClauseMeta = hasLens

exprCstrSite' :: CstrSite -> Expr
exprCstrSite' = ExprCstrSite $ defaultExprMeta 0

declCstrSite' :: CstrSite -> Decl
declCstrSite' = DeclCstrSite $ defaultMeta 0

whereCstrSite' :: CstrSite -> WhereClause
whereCstrSite' = WhereCstrSite $ defaultMeta 0

defaultExprMeta :: Int -> ExprMeta
defaultExprMeta n
    = ExprMeta { parenthesisLevels = 0, standardMeta = defaultMeta n }

defaultMeta :: Int -> Meta
defaultMeta n
    = Meta { interstitialWhitespace = replicate n ""
           , elided = False
           , focused = False
           , evaluationOutput = mempty
           }

-- Note that expressions may have the precedence of literals when parenthesized
instance Expression Expr where
    precedence Abstraction{} = 3
    precedence Sum{} = 2
    precedence Application{} = 1
    precedence Variable{} = 0
    precedence ExprCstrSite{} = 0
    fixity Abstraction{} = Just Prefix
    fixity Application{} = Just Infix
    fixity Sum{} = Just Infix
    fixity Variable{} = Nothing
    fixity ExprCstrSite{} = Nothing
    associativity Application{} = Just LeftAssociative
    associativity Sum{} = Just LeftAssociative
    associativity Abstraction{} = Nothing
    associativity Variable{} = Nothing
    associativity ExprCstrSite{} = Nothing

parenthesizeExprFromMeta :: (a -> a) -> (Expr -> a) -> Expr -> a
parenthesizeExprFromMeta parenthesize prettyExpr x
    = nTimes (x ^. exprMeta % #parenthesisLevels) parenthesize $ prettyExpr x

instance IsNode Node

instance IsNode Expr

instance IsNode Decl

instance IsNode WhereClause

instance NodePrism Node where
    nodePrism = castOptic simple

instance NodePrism Expr where
    nodePrism = _ExprNode

instance NodePrism Decl where
    nodePrism = _DeclNode

instance NodePrism WhereClause where
    nodePrism = _WhereNode

instance CstrSiteNode Node where
    setCstrSite cstrSite = \case
        ExprNode expr -> ExprNode $ setCstrSite cstrSite expr
        DeclNode expr -> DeclNode $ setCstrSite cstrSite expr
        WhereNode expr -> WhereNode $ setCstrSite cstrSite expr
    _NodeCstrSite
        = singular
        $ (_ExprNode % _NodeCstrSite)
        `adjoin` (_DeclNode % _NodeCstrSite)
        `adjoin` (_WhereNode % _NodeCstrSite)

instance CstrSiteNode Expr where
    setCstrSite = const . exprCstrSite'
    _NodeCstrSite
        = _ExprCstrSite
        % unsafeFiltered
            ((== 0) . view (_1 % #parenthesisLevels)) -- safe, because value with predicate is disjoint from focus
        % _2

instance CstrSiteNode Decl where
    setCstrSite = const . declCstrSite'
    _NodeCstrSite = _DeclCstrSite % _2

instance CstrSiteNode WhereClause where
    setCstrSite = const . whereCstrSite'
    _NodeCstrSite = _WhereCstrSite % _2

instance ToString Identifier where
    toString (Identifier name) = map unAlphanumeric $ toList name

instance Pretty Identifier where
    pretty = pretty . toString

instance DisplayProjection Node where
    -- _NodeCstrSite of Node finds construction sites from the nodes and would skip any overridden renderDoc definitions, though there are none now
    renderDoc (ExprNode expr) = renderDoc expr
    renderDoc (DeclNode decl) = renderDoc decl
    renderDoc (WhereNode whereClause) = renderDoc whereClause

-- At the moment, `renderDoc e` will not place additional parentheses to ensure the rendered program reflects the AST according to the grammar and associativity/fixity of the operators
-- This functionality could be copied from the pretty printing definition if needed
instance DisplayProjection Expr

instance DisplayProjection Decl

instance DisplayProjection WhereClause

instance Decomposable Node where
    traverseComponents traverseChar traverseNode = \case
        ExprNode expr ->
            ExprNode <$> traverseComponents traverseChar traverseNode expr
        DeclNode decl ->
            DeclNode <$> traverseComponents traverseChar traverseNode decl
        WhereNode whereClause -> WhereNode
            <$> traverseComponents traverseChar traverseNode whereClause

instance Decomposable Identifier where
    conservativelyDecompose _ _ = Nothing
    traverseComponents traverseChar _ identifier@(Identifier _)
        = traverseOf (_Identifier % traversed % #unAlphanumeric)
                     traverseChar
                     identifier

instance Decomposable Expr where
    traverseComponents traverseChar traverseNode e
        | e ^. exprMeta % #parenthesisLevels > 0
            = chainDisJoint e
            $ Disjoint
                [ keyWordCharTraversal traverseChar '('
                , whitespaceFragmentTraverser _head traverseChar
                , Traverser'
                      (refracting (exprMeta % #parenthesisLevels)
                                  (subtracting 1)
                       % refracting
                           (exprMeta % #standardMeta % #interstitialWhitespace)
                           (_tail % _init))
                      traverseNode
                , whitespaceFragmentTraverser _last traverseChar
                , keyWordCharTraversal traverseChar ')'
                ]
    traverseComponents traverseChar traverseNode e
        = chainDisJoint e
        . Disjoint
        . intersperseWhitespaceTraversers traverseChar e
        $ case e of
            -- All these cases could be composed into 1, because the lenses don't overlap, but this is better for totality checking
            Variable{} -> [ Traverser' (_Variable % _2)
                            $ traverseComponents traverseChar traverseNode
                          ]
            Abstraction{} -> [ keyWordCharTraversal traverseChar '\\'
                             , Traverser' (_Abstraction % _2)
                               $ traverseComponents traverseChar traverseNode
                             , keyWordCharTraversal traverseChar '='
                             , Traverser' (_Abstraction % _3) traverseNode
                             ]
            Application{} -> [ Traverser' (_Application % _2) traverseNode
                             , Traverser' (_Application % _3) traverseNode
                             ]
            Sum{} -> [ Traverser' (_Sum % _2) traverseNode
                     , keyWordCharTraversal traverseChar '+'
                     , Traverser' (_Sum % _3) traverseNode
                     ]
            ExprCstrSite{} -> [ Traverser' (_ExprCstrSite % _2)
                                $ traverseComponents traverseChar traverseNode
                              ]

instance Decomposable Decl where
    traverseComponents traverseChar traverseNode decl@Decl{}
        = chainDisJoint decl . Disjoint
        $ intersperseWhitespaceTraversers
            traverseChar
            decl
            [ Traverser' #name (traverseComponents traverseChar traverseNode)
            , keyWordCharTraversal traverseChar '='
            , Traverser' #value traverseNode
            ]
    traverseComponents traverseChar traverseNode (DeclCstrSite meta materials)
        = DeclCstrSite meta
        <$> traverseComponents traverseChar traverseNode materials

instance Decomposable WhereClause where
    traverseComponents traverseChar
                       traverseNode
                       whereClause@(WhereClause _ decls)
        = chainDisJoint whereClause . Disjoint
        $ intersperseWhitespaceTraversers
            traverseChar
            whereClause
            (Traverser' (castOptic united)
                        (<$ traverse_ @[] traverseChar "where")
             : imap (\i _ -> Traverser' (_WhereClause % _2 % ix i) traverseNode)
                    (toList decls))
    traverseComponents traverseChar traverseNode (WhereCstrSite meta materials)
        = WhereCstrSite meta
        <$> traverseComponents traverseChar traverseNode materials

keyWordCharTraversal
    :: (Is A_Lens k, Functor f) => (t -> f b) -> t -> Traverser' f k NoIx a
keyWordCharTraversal traverseChar c
    = Traverser' (castOptic united) (<$ traverseChar c)

intersperseWhitespaceTraversers :: (Applicative f, Has Meta n)
    => (Char -> f Char)
    -> n
    -> [Traverser' f An_AffineTraversal NoIx n]
    -> [Traverser' f An_AffineTraversal NoIx n]
intersperseWhitespaceTraversers traverseChar n traversers
    = interleave
        [ traversers
        , imap (\i _ -> whitespaceFragmentTraverser (ix i) traverseChar)
          $ view (hasLens @Meta % #interstitialWhitespace) n
        ]

whitespaceFragmentTraverser
    :: (Has Meta s, Is l An_AffineTraversal, Applicative f)
    => Optic' l is [Text] Text
    -> (Char -> f Char)
    -> Traverser' f An_AffineTraversal is s
whitespaceFragmentTraverser selector traverseChar
    = Traverser' (hasLens @Meta
                  % #interstitialWhitespace
                  % castOptic @An_AffineTraversal selector)
                 (unpacked % traversed %%~ traverseChar)

class ValidInterstitialWhitespace a where
    validInterstitialWhitespace :: a -> Int

instance ValidInterstitialWhitespace Expr where
    validInterstitialWhitespace
        e = view (hasLens @ExprMeta % #parenthesisLevels) e * 2 + case e of
        Variable{} -> 0
        Abstraction{} -> 3
        Application{} -> 1
        Sum{} -> 2
        ExprCstrSite{} -> 0

instance ValidInterstitialWhitespace Decl where
    validInterstitialWhitespace = \case
        Decl{} -> 2
        DeclCstrSite{} -> 0

instance ValidInterstitialWhitespace WhereClause where
    validInterstitialWhitespace = \case
        WhereClause _ decls -> length decls
        WhereCstrSite{} -> 0

instance Validity Node

instance Validity Identifier

instance Validity Expr where
    validate
        = mconcat
            [ genericValidate
            , validateInterstitialWhitespace validInterstitialWhitespace
            , declare "has non-empty center whitespace fragment"
              . fromMaybe True
              . preview
                  (_Application
                   % _1
                   % #standardMeta
                   % #interstitialWhitespace
                   % to (maybe False (not . Text.null) . \whitespaceFragments ->
                         guard (odd $ length whitespaceFragments)
                         *> whitespaceFragments
                         !!? (length whitespaceFragments `div` 2)))
            ]

instance Validity Decl where
    validate
        = mconcat [ genericValidate
                  , validateInterstitialWhitespace validInterstitialWhitespace
                  ]

instance Validity WhereClause where
    validate
        = mconcat [ genericValidate
                  , validateInterstitialWhitespace validInterstitialWhitespace
                  , hasNonEmptyInterstitialWhitespace
                  ]

instance Validity AbstractionMeta

instance Validity ExprMeta where
    validate
        = mconcat
            [ genericValidate
            , decorate
                  "The number of surrounding parentheses (parenthesisLevels)"
              . declare "is greater than or equal to 0"
              . (>= 0)
              . parenthesisLevels
            , decorate "The standardMeta"
              . declare "The number of whitespace fragments is greater or equal then twice the number of surrounding parentheses (parenthesisLevels * 2)"
              . \ExprMeta{..} -> length (interstitialWhitespace standardMeta)
              >= parenthesisLevels
            ]

instance Validity Meta where
    validate
        = mconcat [ genericValidate
                  , decorate "The interstitial whitespace"
                    . flip decorateList validateWhitespace
                    . interstitialWhitespace
                  ]

instance Validity EvaluationOutput where
    validate _ = valid

validateInterstitialWhitespace :: Has Meta a => (a -> Int) -> a -> Validation
validateInterstitialWhitespace expectedWhitespaceFragmentCount n
    = mconcat [ genericValidate
              , declare "has the correct number of whitespace fragments"
                . (== expectedWhitespaceFragmentCount n)
                . length
                . interstitialWhitespace
              ]
    $ getter n

hasNonEmptyInterstitialWhitespace :: Has Meta a => a -> Validation
hasNonEmptyInterstitialWhitespace
    = validateInterstitialWhitespaceWith
        (declare "is not empty" . not . Text.null)

validateInterstitialWhitespaceWith
    :: Has Meta b => (Text -> Validation) -> b -> Validation
validateInterstitialWhitespaceWith extraValidation
    = decorate "Meta"
    . decorate "The interstitial whitespace"
    . flip decorateList (validateWhitespace <> extraValidation)
    . interstitialWhitespace
    . getter

instance GenValid Node where
    genValid = sized uniformValid
    shrinkValid = shrinkValidStructurallyWithoutExtraFiltering

instance GenValid Identifier where
    genValid = sized uniformValid
    shrinkValid = shrinkValidStructurallyWithoutExtraFiltering

instance GenValid Expr where
    genValid = sized uniformValid
    shrinkValid = shrinkValidStructurallyWithoutExtraFiltering -- No filtering required, because shrinking Meta maintains the number of interstitial whitespace fragments

instance GenValid Decl where
    genValid = sized uniformValid
    shrinkValid = shrinkValidStructurallyWithoutExtraFiltering -- No filtering required, because shrinking Meta maintains the number of interstitial whitespace fragments

instance GenValid WhereClause where
    genValid = sized uniformValid
    shrinkValid = shrinkValidStructurallyWithoutExtraFiltering -- No filtering required, because shrinking Meta maintains the number of interstitial whitespace fragments

instance GenValid AbstractionMeta where
    genValid = sized . uniformWith $ enumerateValidAbstractionMeta 0
    shrinkValid absMeta@AbstractionMeta{..}
        = map (flip (set #standardExprMeta) absMeta)
        $ shrinkValidStructurallyWithoutExtraFiltering standardExprMeta -- No filtering required, because shrinking Meta maintains the number of interstitial whitespace fragments

instance GenValid ExprMeta where
    genValid = QuickCheck.sized . uniformWith $ enumerateValidExprMeta 0
    shrinkValid = shrinkValidStructurallyWithoutExtraFiltering -- No filtering required since shrinking Ints does not shrink to negative numbers

instance GenValid Meta where
    genValid = QuickCheck.sized . uniformWith $ enumerateValidMeta 0
    shrinkValid meta@Meta{interstitialWhitespace}
        = shrinkValidStructurallyWithoutExtraFiltering interstitialWhitespace
        -- ensure number of whitespace fragments is preserved
        & filter ((length interstitialWhitespace ==) . length)
        -- ensure only characters from previous whitespace fragments are used
        & mapped % imapped
        %@~ (\i whitespaceFragment -> Text.take (Text.length whitespaceFragment)
             $ interstitialWhitespace Unsafe.!! i)
        & fmap (flip (set #interstitialWhitespace) meta)

instance ValidEnumerable Node where
    enumerateValid = datatype [ c1 ExprNode, c1 DeclNode, c1 WhereNode ]

instance ValidEnumerable Identifier where
    enumerateValid
        = datatype [ Identifier .: (:|) <$> accessValid
                     <*> inflation ((2 ^) . (`div` 5)) [] ((:) <$> accessValid)
                   ]

instance ValidEnumerable Expr where
    enumerateValid
        = datatype
            [ Variable <$> enumerateValidExprMeta 0 <*> accessValid
            , splurge 2
              $ Abstraction <$> enumerateValidAbstractionMeta 3
              <*> accessValid
              <*> accessValid
            , Application .: setCenterWhitespace <$> accessValid
              <*> enumerateValidExprMeta 0
              <*> accessValid
              <*> accessValid
            , Sum <$> enumerateValidExprMeta 2 <*> accessValid <*> accessValid
            , ExprCstrSite <$> enumerateValidExprMeta 0 <*> accessValid
            ]
      where
        setCenterWhitespace nonEmptyWhitespace
            = #standardMeta % #interstitialWhitespace %~ \whitespaceFragments ->
            insertAt (length whitespaceFragments `div` 2)
                     (toText . map unWhitespace
                      $ toList @(NonEmpty _) nonEmptyWhitespace)
                     whitespaceFragments

instance ValidEnumerable Decl where
    enumerateValid
        = datatype [ addMeta (uncurry . Decl), addMeta DeclCstrSite ]

instance ValidEnumerable WhereClause where
    enumerateValid
        = datatype
            [ (\decls -> WhereClause
                   (defaultMeta 0) { interstitialWhitespace = map
                                         (toText
                                          . map unWhitespace
                                          . toList @(NonEmpty _)
                                          . fst)
                                         $ toList decls
                                   }
               $ fmap snd decls) <$> accessValid, addMeta WhereCstrSite ]

-- Not generally safe, see note `addMetaWith`
addMeta
    :: (ValidInterstitialWhitespace n, Sized f, Typeable f, ValidEnumerable a)
    => (Meta -> a -> n)
    -> Shareable f n
addMeta = addMetaWith enumerateValidMeta

-- Only safe when `validInterstitialWhitespace` does not evaluate anything else but the constructor
addMetaWith
    :: (ValidInterstitialWhitespace n, Sized f, Typeable f, ValidEnumerable a)
    => (Int -> Shareable f m)
    -> (m -> a -> n)
    -> Shareable f n
addMetaWith enumerateValidNodeMeta c
    = flip c <$> accessValid
    <*> (enumerateValidNodeMeta
         . validInterstitialWhitespace
         . c (error "Default meta was evaluated during enumeration")
         $ error "Dummy node children evaluated during enumeration")

enumerateValidAbstractionMeta
    :: (Typeable f, Sized f) => Int -> Shareable f AbstractionMeta
enumerateValidAbstractionMeta n
    = pay $ AbstractionMeta <$> enumerateValidExprMeta n ?? Nothing

enumerateValidExprMeta :: (Typeable f, Sized f) => Int -> Shareable f ExprMeta
enumerateValidExprMeta minimumWhitespaceFragments
    = pay
    $ (\meta' parenthesisWhitespace ->
       ExprMeta { parenthesisLevels = length parenthesisWhitespace
                , standardMeta = meta'
                      & #interstitialWhitespace
                      %~ (\whitespaceFragments -> map fst parenthesisWhitespace
                          ++ whitespaceFragments
                          ++ map snd parenthesisWhitespace)
                }) <$> enumerateValidMeta minimumWhitespaceFragments
    <*> inflation (2 ^)
                  []
                  ((:) .: (,) <$> enumerateWhitespace <*> enumerateWhitespace)

enumerateValidMeta :: (Typeable f, Sized f) => Int -> Shareable f Meta
enumerateValidMeta n
    = pay
    $ Meta <$> vectorOf n enumerateWhitespace
    <*> pure False
    <*> pure False
    <*> pure mempty
